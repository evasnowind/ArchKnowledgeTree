# 消息队列高手课-笔记

[TOC]

### 注：本文内容来源于极客时间《消息队列高手课》，本文只是整理汇总、个人学习之用。

## 总览
思维导图
![消息队列总览思维导图](images/消息队列总览思维导图.png)

参考资料
- [RocketMQ 官方文档](https://rocketmq.apache.org/docs/quick-start/)
- [RocketMQ 中国开发者中心](http://rocketmq.cloud/zh-cn/)
- [Kafka 官方文档](http://kafka.apache.org/documentation/)
- [RabbitMQ 官方文档](https://www.rabbitmq.com/documentation.html)

## 01 为何需要消息队列
### 哪些问题适合使用消息队列来解决？
1. 异步处理
   - 问题：如何设计一个秒杀系统？
   - 好处：
     - 可以更快地返回结果
     - 减少等待，自然实现了步骤之间的并发，提升系统总体的性能
2. 流量控制
   - 问题：如何避免过多的请求压垮我们的秒杀系统？
   - 设计思路：使用消息队列隔离网关和后端服务，以达到流量控制和保护后端服务的目的。
3. 服务解耦
    - 问题：对于电商系统，当创建一个新订单时，需要
      - 支付系统需要发起支付流程；
      - 风控系统需要审核订单的合法性；
      - 客服系统需要给用户发短信告知用户；
      - 经营分析系统需要更新统计数据；
    - 解决：MQ
4. 作为发布 / 订阅系统实现一个微服务级系统间的观察者模式
5. 连接流计算任务和数据
6. 用于将消息广播给大量接收者

### 引入MQ所带来的问题
1. 增加延迟
2. 增加系统复杂性
3. 可能产生数据不一致


## 02 该如何选择消息队列？
### 选择标准
- 开源
- 近年来比较流行，有一定社区活跃度
- 流行的产品与周边生态系统会有一个比较好的集成和兼容
- 必备的产品特性：
  - 消息的可靠传递
  - 支持集群
  - 具备足够好的性能

### 可供选择的开源产品

现状 | 产品 | 特点  | 问题 
- |  - | - | - 
第一梯队 | RabbitMQ | 轻量级、容易部署；<br/>支持非常灵活的路由配置；<br/>客户端支持的编程语言非常广泛，兼容性好 | 对消息堆积的支持并不好；<br/>与RocketMQ、Kafka相比，性能相对较差（每秒处理几万-几十万）；<br/>实现语言是Erlang，学习曲线较为陡峭，不利于扩展或是二次开发
第一梯队 | RocketMQ | 阿里出品，性能、稳定性和可靠性经受多次双十一考验，值得信赖；<br/>中文社区活跃，容易扩展或是二次开发；<br/>对在线业务的响应时延做了很多的优化，大多数情况下可以做到毫秒级的响应，如果你的应用场景很在意响应时延，可尝试之；<br/>每秒钟大概能处理几十万条消息，高出RabbitMQ一个量级 | 国产，国际上没有那么流行，周边生态系统集成和兼容程序略逊色
第一梯队 | Kafka | 设计初衷：处理海量的日志；<br/>与周边生态系统的兼容性是最好的没有之一，尤其在大数据和流计算领域，几乎所有的相关开源软件系统都会优先支持 Kafka；<br/>Kafka 的性能，尤其是异步收发的性能，是三者中最好的，但与 RocketMQ 并没有量级上的差异，大约每秒钟可以处理几十万条消息；<> | 同步收发消息的响应时延比较高。在它的 Broker 中多处使用这种“先攒一波再一起处理”的设计。当每秒钟消息数量不怎么多的时候，Kafka 的时延反而会比较高。所以，Kafka 不太适合在线业务场景。
第二梯队 | ActiveMQ | 最老牌的开源消息队列；<br/>目前已进入老年期，社区不活跃
第二梯队 | ZeroMQ | 严格来说 ZeroMQ 并不能称之为一个消息队列，而是一个基于消息队列的多线程网络库，如果你的需求是将消息队列的功能集成到你的系统进程中，可以考虑使用 ZeroMQ。
第二梯队 | Pulsar | 最早是由 Yahoo 开发，目前处于成长期，流行度和成熟度相对没有那么高；<br/>Pulsar 采用存储和计算分离的设计


## 03 消息模型：主题和队列有什么区别？
早期的MQ，都是按照队列模型设计：
![03队列模型.jpg](images/02队列模型.jpg)

问题：多个消费者的情况，只能多个队列
进一步解决：发布-订阅模型
![03发布订阅模型.jpg](images/02发布订阅模型.jpg)

队列模式和发布 - 订阅模式，最大区别：一份消息数据能不能被消费多次的问题。
现代的消息队列产品使用的消息模型大多是这种发布 - 订阅模型，当然也有例外，比如RabbitMQ

### RabbitMQ消息模型
![03RabbitMQ模型.jpg](images/02RabbitMQ模型.jpg)
利用exchange，变相地实现新发布 - 订阅模型中，“一份消息数据可以被多个订阅者来多次消费”这样的功能。

### RocketMQ消息模型
![03RocketMQ模型.jpg](images/02RocketMQ模型.jpg)
标准的发布 - 订阅模型

概念：
生产者、消费者和主题
队列

“请求 - 确认”机制：确保消息不会在传递过程中由于网络或服务器故障丢失。具体的做法也非常简单。
- 在生产端，生产者先将消息发送给服务端，也就是 Broker，服务端在收到消息并将消息写入主题或者队列中后，会给生产者发送确认的响应。
- 在消费端，消费者在收到消息并完成自己的消费业务逻辑（比如，将数据保存到数据库中）后，也会给服务端发送消费成功的确认，服务端只有收到消费确认后，才认为一条消息被成功消费，否则它会给消费者重新发送这条消息，直到收到对应的消费成功确认。

带来的问题：为了确保消息的有序性，在某一条消息被成功消费之前，下一条消息是不能被消费的，否则就会出现消息空洞，违背了有序性这个原则。
——没法通过水平扩展消费者的数量来提升消费端总体的消费性能。为了解决这个问题，RocketMQ 在主题下面增加了队列的概念。

重要概念：
订阅者：Consumer Group 消费组
不同消费组之间消费进度彼此不受影响，同一个组内的消费者是竞争消费的关系

消费位置 Consumer Offset


### Kafka 的消息模型
Kafka 的消息模型和 RocketMQ 是完全一样的，唯一的区别是，在 Kafka 中，队列这个概念的名称不一样，Kafka 中对应的名称是“分区（Partition）”，含义和功能是没有任何区别的。

### 思考题
Q1：rocketmq，一个消费组在一个主题下的多个队列并发消费就无法保证消息的顺序性。这种该如何处理?
A1：按照订单ID或者用户ID，用一致性哈希算法，计算出队列ID，指定队列ID发送，这样可以保证相同的订单/用户的消息总被发送到同一个队列上，就可以确保严格顺序了。

Q2：在介绍 RocketMQ 的消息模型时讲过，在消费的时候，为了保证消息的不丢失和严格顺序，每个队列只能串行消费，无法做到并发，否则会出现消费空洞的问题。那如果放宽一下限制，不要求严格顺序，能否做到单个队列的并行消费呢？如果可以，该如何实现？
理解：生产者允许多生产者同时生产消息，每条消息只会被主题中的某条队列接收，消费组内的消费者竞相消费所有队列，消费者会根据消费组在队列上的数来记录已消费位置，做到的就是队列上的有序，但是有可能整个topic下，是无序的。有可能图中的4要先被消费，但是另一队列中的3还没被消费。
所以如果需要有序，就需要发送到同一条队列中去了。
A2：今天的思考题，我觉得应该是，把消息队列的先进先出，改成数组的随机访问，用offset来控制消息组具体要消费哪条消息，mq不主动删除消息，消息有过期时间，如果到了过期时间，只能确认不能重新该消费，只保留最大可设置天数的消息。超过该天数则删除，还要维护客户端确认信息，如果有客户端没确认，需要有重发机制。
作者回复: 现代的消息队列大多就是这么实现的。


## 04 如何利用事务消息实现分布式事务？
很多场景下，我们“发消息”这个过程，目的往往是通知另外一个系统或者模块去更新数据，消息队列中的“事务”，主要解决的是消息生产者和消息消费者的数据一致性问题。

例子：电商系统-购物流程：商品加到购物车里，下单，支付
![04购物流程.jpg](images/04购物流程.jpg)

这个过程中有一个需要用到消息队列的步骤，订单系统创建订单后，发消息给购物车系统，将已下单的商品从购物车中删除。
——使用消息队列来异步清理购物车

### 分布式事务

常见分布式事务实现：
- 2PC：Two-phase Commit，二阶段提交
- TCC：Try-Confirm-Cancel，
- 事务消息
  - 适用场景：需要异步更新数据，并且对数据实时性要求不太高的场景。

### 消息队列是如何实现分布式事务的？
需要MQ支持。
![04订单系统事务消息.jpg](images/04订单系统事务消息.jpg)
“半消息”：包含的内容就是完整的消息内容，半消息和普通消息的唯一区别是，在事务提交之前，对于消费者来说，这个消息是不可见的

如果在步骤4提交事务时失败，如何处理？
- Kafka 直接抛出异常，用户自行处理
- RocketMQ 另一种方式

### RocketMQ 中的分布式事务实现
增加了事务反查的机制来解决事务消息提交失败的问题:
提交“半消息”后，若RocketMQ 的 Broker 没有收到提交或者回滚的请求,Broker会定期去Producer上反查这个事务对应的本地事务的状态，然后根据反查结果决定提交或者回滚这个事务
业务代码需要实现一个反查本地事务状态的接口，告知 RocketMQ 本地事务是成功还是失败。

![04RocketMQ事务反查机制.jpg](images/04RocketMQ事务反查机制.jpg)

### 思考题
RocketMQ 的这种事务消息是不是完整地实现了事务的 ACID 四个特性？如果不是，哪些特性没有实现？
评论：A:本地事物的操作1，与往消息队列中生产消息的操作2，是两个分离的操作，不符合对原子性的定义；
C:由于操作消息队列属于异步操作，在数据一致性上，只能保证数据的最终一致性。若对于时效性要求很高的系统来说，事物消息不是数据一致的；但对于时效性要求不高的系统来说，他就是数据一致的。我认为，用不同的业务视角来看问题，会有不同的答案；
I：隔离性上，由于事物消息是分两步操作的，本地事物提交后，别的事物消息就已经可以看到提交的消息了。所以，不符合隔离性的定义；
D：持久性上，rocketMq上支持事物的反查机制，但我不太清楚“半消息”是存储在磁盘中，还是内存里。若存储在磁盘中，那就支持持久性，即使事物消息提交后，发生服务突然宕机也不受影响；若存储在内存中，则无法保证持久性。