# 极客时间-MySQL实战45讲学习笔记

## 01 | 基础架构：一条SQL查询语句是如何执行的？

SQL执行示例
```
mysql> select * from T where ID=10；
```

MySQL分为：
- Server层
  - 包括连接器、查询缓存、分析器、优化器、执行器等，涵盖 MySQL 的大多数核心服务功能，以及所有的内置函数（如日期、时间、数学和加密函数等），所有跨存储引擎的功能都在这一层实现，比如存储过程、触发器、视图等。
- 存储引擎
  - 插件式设计，常见：InnoDB, MyISAM, Memory
  - 从5.5 开始默认为InnoDB
  - create table时可以指定存储引擎


### 连接器
查看当前已创建的连接：
```
show processlist
```
客户端如果太长时间没动静，连接器就会自动将它断开。这个时间是由参数 wait_timeout 控制的，默认值是 8 小时。

数据库里面，长连接是指连接成功后，如果客户端持续有请求，则一直使用同一个连接。短连接则是指每次执行完很少的几次查询就断开连接，下次查询再重新建立一个。
建立连接的过程通常是比较复杂的，所以我建议你在使用中要尽量减少建立连接的动作，也就是尽量使用长连接。

但全部使用长连接后，你可能会发现，有些时候 MySQL 占用内存涨得特别快
——MySQL 在执行过程中临时使用的内存是管理在连接对象里面的，连接断开时才会释放。如果长连接累积下来，可能导致内存占用太大，被系统强行杀掉（OOM），从现象看就是 MySQL 异常重启了。

解决长连接导致OOM、继而导致MySQL异常重启的方法：
- 定期断开长连接。
- 如果你用的是 MySQL 5.7 或更新版本，可以在每次执行一个比较大的操作后，通过执行 mysql_reset_connection 来重新初始化连接资源。这个过程不需要重连和重新做权限验证，但是会将连接恢复到刚刚创建完时的状态。


### 查询缓存
大多数情况下我会建议你不要使用查询缓存，因为查询缓存往往弊大于利。
查询缓存的失效非常频繁，只要有对一个表的更新，这个表上所有的查询缓存都会被清空。除非你的业务就是有一张静态表，很长时间才会更新一次。比如，一个系统配置表，那这张表上的查询才适合使用查询缓存。
MySQL 也提供了这种“按需使用”的方式。你可以将参数 query_cache_type 设置成 DEMAND，这样对于默认的 SQL 语句都不使用查询缓存。而对于你确定要使用查询缓存的语句，可以用 SQL_CACHE 显式指定，像下面这个语句一样：

```
mysql> select SQL_CACHE * from T where ID=10；
```
8.0 开始彻底没有查询缓存功能。

### 分析器
### 优化器
### 执行器
在数据库的慢查询日志中看到一个 rows_examined 的字段，表示这个语句执行过程中扫描了多少行。这个值就是在执行器每次调用引擎获取数据行的时候累加的。在有些场景下，执行器调用一次，在引擎内部则扫描了多行，因此引擎扫描行数跟 rows_examined 并不是完全相同的。


## 02 | 日志系统：一条SQL更新语句是如何执行的？
在一个表上有更新的时候，跟这个表有关的查询缓存会失效，所以这条语句就会把表 T 上所有缓存结果都清空。

### redo log 重做日志
**WAL 技术**：Write-Ahead Logging，先写日志，再写磁盘
InnoDB 引擎就会先把记录写到 redo log，更新内存，然后在适当的时候（系统较为空闲时）更新磁盘记录。
InnoDB 的 redo log 是固定大小的，结构如下图：
![02-redo-log.png](images/02-redo-log.png)
redo log保证了InnoDB存储引擎在发生异常、重启时，之前提交的记录不会丢失——crash-safe能力

### binlog 归档日志
MySQL的结构:
- server层
  - binlog，只用于归档
- 存储引擎层
  - MySQL 自带的引擎是 MyISAM没有redo log，InnoDB是以插件形式集成进来，InnoDB自己为保证crash-safe才实现了redo log

binlog与redo log区别：
- redo log是InnoDB特有，binlog在MySQL server层，所有引擎可用
- redo log是物理日志，binlog是逻辑日志
- redo log循环写入，binlog追加写入

Redo log不是记录数据页“更新之后的状态”，而是记录这个页 “做了什么改动”。
Binlog有两种模式，statement 格式的话是记sql语句， row格式会记录行的内容，记两条，更新前和更新后都有。

### binlog不能去掉
- redo log只有InnoDB有，别的引擎没有。
- redolog是循环写的，不持久保存，binlog的“归档”这个功能，redolog是不具备的。

其核心就是， redo log 记录的，即使异常重启，都会刷新到磁盘，而 bin log 记录的， 则主要用于备份。

### 为什么日志需要“两阶段提交”
redo log 和 binlog 都可以用于表示事务的提交状态，而两阶段提交就是让这两个状态保持逻辑上的一致。

## 03 | 事务隔离：为什么你改了我还看不见？

### 隔离性与隔离级别
ACID（Atomicity、Consistency、Isolation、Durability，即原子性、一致性、隔离性、持久性）

多个事务同时执行，可能出现：
脏读（dirty read）、不可重复读（non-repeatable read）、幻读（phantom read）的问题
——隔离级别

SQL 标准的事务隔离级别包括：
- 读未提交（read uncommitted）
- 读提交（read committed）
- 可重复读（repeatable read）
  - 事务在执行期间看到的数据前后必须是一致的
- 串行化（serializable ）
隔离级别越高，效率越低，需要权衡。

Oracle 数据库的默认隔离级别是“读提交”
MySQL默认隔离级别是“可重复读”
——从Oracle迁移到MySQL，为保证数据库隔离级别的一致，你一定要记得将 MySQL 的隔离级别设置为“读提交”，即将启动参数 transaction-isolation 的值设置成 READ-COMMITTED
查看方式：
```
show variables like 'transaction_isolation';
```
### 事务隔离的实现

为何建议尽量不使用长事务？
- 对回滚段的影响
- 占用锁资源
- 可能拖垮整个库

参考文章：[MySQL-长事务详解](https://www.cnblogs.com/kunjian/p/11552646.html)


### 事务的启动方式
MySQL 的事务启动方式有以下几种：
1. 显式启动：begin 或 start transaction。配套的提交语句是 commit，回滚语句是 rollback。
2. set autocommit=0，这个命令会将这个线程的自动提交关掉。意味着如果你只执行一个 select 语句，这个事务就启动了，而且并不会自动提交。这个事务持续存在直到你主动执行 commit 或 rollback 语句，或者断开连接。

建议总是使用 set autocommit=1, 通过显式语句的方式来启动事务。

若纠结“多一次交互”的问题，希望减少交互次数，则建议使用**commit work and chain 语法**

可以在 information_schema 库的 innodb_trx 这个表中查询长事务
如下面这个语句，用于查找持续时间超过 60s 的事务：
```
select * from information_schema.innodb_trx where TIME_TO_SEC(timediff(now(),trx_started))>60
```

### 参考资料
- [MySQL-长事务详解](https://www.cnblogs.com/kunjian/p/11552646.html)


## 04 | 深入浅出索引（上）
### 索引的常见模型：
- 哈希表：适用于只有等值查询的场景，比如 Memcached 及其他一些 NoSQL 引擎。
- 有序数组：在等值查询和范围查询场景中的性能就都非常优秀，只适用于静态存储引擎
- N 叉树
- 其他：跳表、LSM 树等

### InnoDB 的索引模型
B+ 树
根据叶子节点的内容，索引类型分为：主键索引和非主键索引
主键索引的叶子节点存的是整行数据。在 InnoDB 里，主键索引也被称为聚簇索引（clustered index）。
非主键索引的叶子节点内容是主键的值。在 InnoDB 里，非主键索引也被称为二级索引（secondary index）。
基于主键索引和普通索引的查询有什么区别？
——基于非主键索引的查询需要多扫描一棵索引树。因此，我们在应用中应该尽量使用主键查询。

### 索引维护
选择自增字段作为主键，还是采用业务字段作为主键？
主键长度越小，普通索引的叶子节点就越小，普通索引占用的空间也就越小。从性能和存储空间方面考量，自增主键往往是更合理的选择。

有些业务的场景需求是这样的：只有一个索引，且该索引必须是唯一索引（KV场景）
——没有其他索引，不用考虑其他索引叶子节点大小问题，直接用业务字段即可。



## 05 | 深入浅出索引（下）
回到主键索引树搜索的过程，我们称为回表

### 覆盖索引
```
select * from T where k between 3 and 5
```
需要回表。

```
select ID from T where k between 3 and 5
```
覆盖索引
**由于覆盖索引可以减少树的搜索次数，显著提升查询性能，所以使用覆盖索引是一个常用的性能优化手段。**

应用：
市民信息表中有姓名、身份证号字段：
针对利用身份证号查询市民信息：索引仅建在身份证号即可
若有利用身份证号查姓名的高频需求：额外创建（身份证号、姓名）的联合索引，避免回表，直接覆盖索引

### 最左前缀原则
**在建立联合索引的时候，如何安排索引内的字段顺序。**
评估标准是，索引的复用能力
- **第一原则是，如果通过调整顺序，可以少维护一个索引，那么这个顺序往往就是需要优先考虑采用的**
  - 当已经有了 (a,b) 这个联合索引后，一般就不需要单独在 a 上建立索引了
- 索引占用空间

### 索引下推
MySQL 5.6 引入索引下推优化（index condition pushdown)， 可以在索引遍历过程中，对索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数。


## 06 | 全局锁和表锁 ：给表加个字段怎么有这么多阻碍？
根据加锁的范围，MySQL 里面的锁大致可以分成全局锁、表级锁和行锁三类。

### 全局锁
全局锁就是对整个数据库实例加锁。MySQL 提供了一个加全局读锁的方法，命令是 Flush tables with read lock (FTWRL)。

**全局锁的典型使用场景是，做全库逻辑备份。**也就是把整库每个表都 select 出来存成文本。
——另一种思路：如果是InnoDB这种支持事务的引擎，可以在可重复读隔离级别下开启一个事务，以便保证备份过程中看到的是一致性视图。MyISAM不支持事务，只能用FTWRL了。

官方自带的逻辑备份工具是 mysqldump。当 **mysqldump** 使用参数**–single-transaction** 的时候，导数据之前就会启动一个事务，来确保拿到一致性视图。
——single-transaction 方法只适用于所有的表使用事务引擎的库。

既然要全库只读，为什么不使用 set global readonly=true 的方式呢？
- 在有些系统中，readonly 的值会被用来做其他逻辑，比如用来判断一个库是主库还是备库。
- 在异常处理机制上有差异。

### 表级锁
MySQL 里面表级别的锁有两种：一种是表锁，一种是元数据锁（meta data lock，MDL)。
表锁的语法是 lock tables … read/write。
需要注意，lock tables 语法除了会限制别的线程的读写外，也限定了本线程接下来的操作对象。

另一类表级的锁是 MDL（metadata lock)。
MDL 不需要显式使用，在访问一个表的时候会被自动加上：读锁之间不互斥，读写锁之间、写锁之间是互斥的，用来保证变更表结构操作的安全性。

事务中的 MDL 锁，在语句执行开始时申请，但是语句结束后并不会马上释放，而会等到整个事务提交后再释放。

**问题：如何安全地给小表加字段？**

## 07 | 行锁功过：怎么减少行锁对性能的影响？
MySQL 的行锁是在引擎层由各个引擎自己实现的。但并不是所有的引擎都支持行锁
**在 InnoDB 事务中，行锁是在需要的时候才加上的，但并不是不需要了就立刻释放，而是要等到事务结束时才释放。这个就是两阶段锁协议。**
——如果你的事务中需要锁多个行，要把最可能造成锁冲突、最可能影响并发度的锁尽量往后放。

### 死锁和死锁检测
数据库死锁时，有两种策略：
- 直接进入等待，直至超过超时时间。超时时间配置innodb_lock_wait_timeout。默认值为50s。
- 发起死锁检测，发现死锁后，主动回滚死锁链条中的某一个事务.参数 innodb_deadlock_detect 设置为 on 则表示开启死锁检测。

怎么解决由这种热点行更新导致的性能问题呢？
——死锁检测要耗费大量的 CPU 资源
