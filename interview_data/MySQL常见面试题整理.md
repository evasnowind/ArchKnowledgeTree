# MySQL常见面试题整理

## 1. 数据库常见隔离级别？各自的含义？MySQL默认的隔离级别是？



## 2. 脏读、不可重复读、幻读？

- 脏读：
- 不可重复读：事务A开启事务后，两次读同一行数据，发现返回的是不同数据。
- 幻读：
  - 前提条件：InnoDB引擎，可重复读隔离级别，使用当前读时。
  - 表现：一个事务(同一个read view)在前后两次查询同一范围的时候，后一次查询看到了前一次查询没有看到的行。
    - 两点需要说明：　　
      - 1、在可重复读隔离级别下，普通查询是快照读，是不会看到别的事务插入的数据的，幻读只在当前读下才会出现。　
      - 2、幻读专指新插入的行，读到原本存在行的更新结果不算。因为当前读的作用就是能读到所有已经提交记录的最新值。

在sql标准中，rr会存在幻读问题，幻读会导致write skew。mysql用mvcc实现rr隔离级别后也存在幻读，所以又使用next-key lock，解决了由幻读导致的write skew问题。



## 3. MySQL存储引擎有哪些？各自的优缺点？



## 4. 高并发下，如何做到安全的修改同一行数据？

参考：

- https://blog.csdn.net/qq_41572697/article/details/89920216
- https://blog.csdn.net/riemann_/article/details/89980750

回答：

- 使用悲观锁
  - JVM Synchorized 关键字，或是ReentranLock
  - 数据库的悲观锁
  - 分布式锁
    - redis
    - zookeeper
- 使用FIFO缓存队列
  - 比如可以使用Distruptor
- 使用乐观锁
  - 带版本号更新
    - ——相对好一些的解决思路

## 5. 乐观锁和悲观锁？MySQL InnoDB标准行级锁有哪两种？解释一下

参考资料：https://www.jianshu.com/p/ed896335b3b4

- 乐观锁
  - 乐观锁相对悲观锁而言，它认为数据一般情况下不会造成冲突，所以在数据进行提交更新的时候，才会正式对数据的冲突与否进行检测，如果发现冲突了，则让返回错误信息，让用户决定如何去做。
  - 利用数据版本号（**version**）或是时间戳是乐观锁最常用的一种实现方式。
  - 需要注意的是，如果你的数据表是读写分离的表，当master表中写入的数据没有及时同步到slave表中时会造成更新一直失败的问题。此时，需要强制读取master表中的数据（将select语句放在事物中）。
- 悲观锁
  - **select...for update**是MySQL提供的实现悲观锁的方式。
  - **在MySQL中用悲观锁务必须确定走了索引，而不是全表扫描，否则将会将整个数据表锁住**。



有关标准行级锁：

InnoDB实现了以下两种类型的行锁：

- 共享锁（S）：允许一个事务去读一行，阻止其他事务获得相同数据集的排他锁。
- 排他锁（X)：允许获得排他锁的事务更新数据，阻止其他事务取得相同数据集的共享读锁和排他写锁。

另外，为了允许行锁和表锁共存，实现多粒度锁机制，InnoDB还有两种内部使用的意向锁（Intention Locks），这两种意向锁都是表锁。

- 意向共享锁（IS）：事务打算给数据行加行共享锁，事务在给一个数据行加共享锁前必须先取得该表的IS锁。
- 意向排他锁（IX）：事务打算给数据行加行排他锁，事务在给一个数据行加排他锁前必须先取得该表的IX锁。



## 6. 数据库会死锁吗？举个死锁的例子？mysql怎么解决死锁？

​	**1、产生原因：**

所谓死锁：是指两个或两个以上的进程在执行过程中,因争夺资源而造成的一种互相等待的现象,若无外力作用，它们都将无法推进下去.此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程。

**表级锁不会产生死锁.**所以解决死锁主要还是针对于最常用的InnoDB。死锁的关键在于：两个(或以上)的Session加锁的顺序不一致。那么对应的解决死锁问题的关键就是：让不同的session加锁有次序。



## 7. B树和B+树的区别？

简单说：参见https://www.cnblogs.com/xueqiuqiu/articles/8779029.html

https://blog.csdn.net/zhuanzhe117/article/details/78039692

有关b树的一些特性，注意与后面的b+树区分：

1. 关键字集合分布在整颗树中；
2. 任何一个关键字出现且只出现在一个结点中；
3. 搜索有可能在非叶子结点结束（每个节点存储key和data）；
4. 其搜索性能等价于在关键字全集内做一次二分查找；

█b+树相比于b树的查询优势：

1. b+树的中间节点不保存数据，所以磁盘页能容纳更多节点元素，更“矮胖”；
2. b+树查询必须查找到叶子节点，b树只要匹配到即可不用管元素位置，因此b+树查找更稳定（并不慢）；
3. 对于范围查找来说，b+树只需遍历叶子节点链表即可，b树却需要重复地中序遍历，如下两图：



## 8. 页分裂与页合并？









