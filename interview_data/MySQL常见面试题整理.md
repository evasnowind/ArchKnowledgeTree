# MySQL常见面试题整理

## 1. 数据库常见隔离级别？各自的含义？MySQL默认的隔离级别是？



## 2. 脏读、不可重复读、幻读？



## 3. MySQL存储引擎有哪些？各自的优缺点？



## 4. 高并发下，如何做到安全的修改同一行数据？

参考：

- https://blog.csdn.net/qq_41572697/article/details/89920216
- https://blog.csdn.net/riemann_/article/details/89980750

回答：

- 使用悲观锁
  - JVM Synchorized 关键字，或是ReentranLock
  - 数据库的悲观锁
  - 分布式锁
    - redis
    - zookeeper
- 使用FIFO缓存队列
  - 比如可以使用Distruptor
- 使用乐观锁
  - 带版本号更新
    - ——相对好一些的解决思路

## 5. 乐观锁和悲观锁？MySQL InnoDB标准行级锁有哪两种？解释一下

参考资料：https://www.jianshu.com/p/ed896335b3b4

- 乐观锁
  - 乐观锁相对悲观锁而言，它认为数据一般情况下不会造成冲突，所以在数据进行提交更新的时候，才会正式对数据的冲突与否进行检测，如果发现冲突了，则让返回错误信息，让用户决定如何去做。
  - 利用数据版本号（**version**）或是时间戳是乐观锁最常用的一种实现方式。
  - 需要注意的是，如果你的数据表是读写分离的表，当master表中写入的数据没有及时同步到slave表中时会造成更新一直失败的问题。此时，需要强制读取master表中的数据（将select语句放在事物中）。
- 悲观锁
  - **select...for update**是MySQL提供的实现悲观锁的方式。
  - **在MySQL中用悲观锁务必须确定走了索引，而不是全表扫描，否则将会将整个数据表锁住**。



有关标准行级锁：

InnoDB实现了以下两种类型的行锁：

- 共享锁（S）：允许一个事务去读一行，阻止其他事务获得相同数据集的排他锁。
- 排他锁（X)：允许获得排他锁的事务更新数据，阻止其他事务取得相同数据集的共享读锁和排他写锁。

另外，为了允许行锁和表锁共存，实现多粒度锁机制，InnoDB还有两种内部使用的意向锁（Intention Locks），这两种意向锁都是表锁。

- 意向共享锁（IS）：事务打算给数据行加行共享锁，事务在给一个数据行加共享锁前必须先取得该表的IS锁。
- 意向排他锁（IX）：事务打算给数据行加行排他锁，事务在给一个数据行加排他锁前必须先取得该表的IX锁。



## 6. 数据库会死锁吗？举个死锁的例子？mysql怎么解决死锁？

​	**1、产生原因：**

所谓死锁：是指两个或两个以上的进程在执行过程中,因争夺资源而造成的一种互相等待的现象,若无外力作用，它们都将无法推进下去.此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程。

**表级锁不会产生死锁.**所以解决死锁主要还是针对于最常用的InnoDB。死锁的关键在于：两个(或以上)的Session加锁的顺序不一致。那么对应的解决死锁问题的关键就是：让不同的session加锁有次序。









