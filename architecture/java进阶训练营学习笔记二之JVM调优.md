# 极客时间-java进阶训练营学习笔记二之JVM调优



javac 编译，可能报错

```text
编码GBK的不可映射字符
```

使用UTF8的代码代码，直接javac，在windows上可能报这个错，可以加参数指定字符集：

```shell
javac -encoding UTF-8 XXX.java
```

分析过程：

young 

分析具体案例：JDK 8, PS+PO

young gc 时间递增--> 因为young 空间逐步增大

real time:真正暂停的时间

user : 持续时间

sys : 系统时间





PS+PO的默认堆内存，默认值是物理内存的1/4。

模拟OOM：

内存变大，能使GC次数减少，降低OOM概率



用表格的形式比较



PS+PO

Serial

比较回收时间，回收空间，调到内存对GC的影响

不同内存空间，时间变长但效率变高（收集垃圾更多）

serial 使其进行full gc：不断减少堆内存大小，比如128M，但可能此时是无效的，没有收集任何内存，比如设置为128M

计算GC前后young 区、old区的占用率





并行 512M

128M 测试OOM情况：可能不会OOM，只是不断发生GC情况



起始堆内存——不配置Xms干掉



默认：与业务线程一起执行的GC线程数量，不能太大或是太小 PS+PO 1/4

CMS不进行内存整理





G1去掉 PrintDetail参数，可以让日志输出更简单干净一些

想看GC是哪个：

1、先jps -lvm ， 然后jmap -heap

2、看GC日志





死锁：

如何发现死锁：

1、超时时间

2、检测到死锁条件



检测



OOM：

线程相关：

不同系统下，表现不太一样

linux一切皆文件，每个进程/线程都是一个fd，这个默认值可能不高，需要解除限制

可用内存/xss --> 理论上最大可创建多少线程



g1 默认2048个region，超过region一半大小的，就算作是大对象



如何计算对象分配速度——参见PPT





尽量让对象在年轻代时处理干净

——写代码：一个方法内对象不要太多





线程池：配置到几十就够了，过多反而导致线程争抢资源、性能下降



要显式的配置参数：

比如并发线程数量，参见老师的例子

JVM参数没有明确指定的，默认参数都可能是有风险的。

对外内存，默认与Xmx大小一样



一般推荐一个 



java -jar -Xmx1g -Xms1g gateway-server-0.0.1-SNAPSHOT.jar

手工压测：

sb -u http://localhost:8088/api/hello -c 20 -N 60



sb 使用virtualvm 分别使用、不使用飞行记录，看对GC情况



512 CMS比PS好一些

4G 

不同内存下，GC表现会发生变化

一般情况，延迟低，吞吐量的关系：看视频3：50左右

系统越复杂，

4G的时候，吞吐量，G1 CMS比PS也要低一些。所以目前低版本使用PS作为默认，是很有价值，









NIO

sb -u http://localhost:18081 -c 40 -N 30

速度很慢

为何创建40个线程，而不是4个或是8个？

要比核心数量要多：sleep的时候，CPU被让渡出来，CPU可以做别的事情

——B/S模式，往往是CPU参与很少，多数时间可能是在IO相关（网络IO、磁盘IO等）

——————JDK线程池偏向于CPU密集型，可以修改成适合IO密集，参见dubbo tomcat对于线程池的修改





同步、异步，阻塞、非阻塞

同步/异步：callback/listener这种是异步，返回结果的处理在不同线程；同步则是返回结果之后在接着往下处理

我让你买咖啡，好多人在排队，你一直排队等着、买完才回来——既是同步，也是阻塞的

我让你买咖啡，好多人在排队，你手头有很多事儿，让B去买、B买完之后回来给你，对你而言，不耽误手上的事儿，两个人是异步化的处理。——对你来说，异步非阻塞；对我：是同步非阻塞，因为我不知道B，只知道你，在我看来是你去买、买完回来给我结果。类似的：Future.get()



（1）阻塞IO/BIO



epoll的改进：务必要记住



时间驱动架构EDA之后 

​		-->分阶段的事件驱动架构

​				多级缓冲，因为只在一个缓冲的话，挂掉时影响会非常大，多级则可以减小每个缓冲的影响



tomcat 直到3.0之前：都是用线程池里的线程去处理，同步阻塞；

3.0 ：动态servlet 处理一个servlet时，可以进入servlet周期好几次，可以动态



为何说我们写的server是 http server，而不是web server？

有相应规范。

httpserver:无状态的 

webserver: 支持session, 支持jsp

j2ee server: jms, ejb, jndi等标准



jsp和servlet的关系：jsp就是servlet





主流网站：http 2

长连接：用websocket, 实时刷新的网站，比如k线图

UDP 的使用：QQ，DNS

最近两年spring  阿里习惯推 RSocket: 和Netty思路一样，api一样



netty的好处：

零拷贝、屏蔽非业务逻辑



管道+过滤器的设计模式

——自己设计一个系统、框架，都可以采用这种设计思路

例子：订单的处理。

实现1：线性的写代码

实现2：状态机的设计方式，先定义好状态机，然后找状态机框架





