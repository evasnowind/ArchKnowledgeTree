# 05 | 数组：为什么很多编程语言中数组都从0开始编号？

线性表：
- 数组
- 链表
- 队列
- 栈
- ……

非线性表：
- 二叉树
- 堆
- 图
- ……


数组支持随机访问，根据下标随机访问的时间复杂度为 O(1)。

如果使用 ArrayList，我们就完全不需要关心底层的扩容逻辑，ArrayList 已经帮我们实现好了。每次存储空间不够的时候，它都会将空间自动扩容为 1.5 倍大小。

因为扩容操作涉及内存申请和数据搬移，是比较耗时的。所以，**如果事先能确定需要存储的数据大小，最好在创建 ArrayList 的时候事先指定数据大小。**

# 06 | 链表（上）：如何实现LRU缓存淘汰算法?

## 链表类型
- 单链表
- 双向链表
- 循环链表

## 如何基于链表实现 LRU 缓存淘汰算法？
维护一个有序单链表，越靠近链表尾部的结点是越早之前访问的。当有一个新的数据被访问时，我们从链表头开始顺序遍历链表。
1. 如果此数据之前已经被缓存在链表中了，我们遍历得到这个数据对应的结点，并将其从原来的位置删除，然后再插入到链表的头部。
2. 如果此数据没有在缓存链表中，又可以分为两种情况：
   - 如果此时缓存未满，则将此结点直接插入到链表的头部；
   - 如果此时缓存已满，则链表尾结点删除，将新的数据结点插入链表的头部。

这是一道leetcode题目，这个思路是O(n)时间复杂度。

进一步优化：引入散列表（Hash table）来记录每个数据的位置，将缓存访问的时间复杂度降到 O(1)。
