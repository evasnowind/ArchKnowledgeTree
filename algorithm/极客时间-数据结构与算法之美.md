# 05 | 数组：为什么很多编程语言中数组都从0开始编号？

线性表：
- 数组
- 链表
- 队列
- 栈
- ……

非线性表：
- 二叉树
- 堆
- 图
- ……


数组支持随机访问，根据下标随机访问的时间复杂度为 O(1)。

如果使用 ArrayList，我们就完全不需要关心底层的扩容逻辑，ArrayList 已经帮我们实现好了。每次存储空间不够的时候，它都会将空间自动扩容为 1.5 倍大小。

因为扩容操作涉及内存申请和数据搬移，是比较耗时的。所以，**如果事先能确定需要存储的数据大小，最好在创建 ArrayList 的时候事先指定数据大小。**

# 06 | 链表（上）：如何实现LRU缓存淘汰算法?

## 链表类型
- 单链表
- 双向链表
- 循环链表

## 如何基于链表实现 LRU 缓存淘汰算法？
维护一个有序单链表，越靠近链表尾部的结点是越早之前访问的。当有一个新的数据被访问时，我们从链表头开始顺序遍历链表。
1. 如果此数据之前已经被缓存在链表中了，我们遍历得到这个数据对应的结点，并将其从原来的位置删除，然后再插入到链表的头部。
2. 如果此数据没有在缓存链表中，又可以分为两种情况：
   - 如果此时缓存未满，则将此结点直接插入到链表的头部；
   - 如果此时缓存已满，则链表尾结点删除，将新的数据结点插入链表的头部。

这是一道leetcode题目，这个思路是O(n)时间复杂度。

进一步优化：引入散列表（Hash table）来记录每个数据的位置，将缓存访问的时间复杂度降到 O(1)。

# 07 | 链表（下）：如何轻松写出正确的链表代码？

## 技巧一：理解指针或引用的含义
将某个变量赋值给指针，实际上就是将这个变量的地址赋值给指针，或者反过来说，指针中存储了这个变量的内存地址，指向了这个变量，通过指针就能找到这个变量。

## 技巧二：警惕指针丢失和内存泄漏

插入结点时，一定要注意操作的顺序
删除链表结点时，也一定要记得手动释放内存空间

## 技巧三：利用哨兵简化实现难度
针对链表的插入、删除操作，需要对插入第一个结点和删除最后一个结点的情况进行特殊处理。


## 技巧四：重点留意边界条件处理

## 技巧五：举例画图，辅助思考

## 技巧六：多写多练，没有捷径
5 个常见的链表操作:
- 单链表反转
- 链表中环的检测
- 两个有序的链表合并
- 删除链表倒数第 n 个结点
- 求链表的中间结点

练习题LeetCode对应编号：206，141，21，19，876


# 09 | 队列：队列在线程池等有限资源池中的应用

- 顺序队列和链式队列
- 循环队列
- 阻塞队列和并发队列


实际上，对于大部分资源有限的场景，当没有空闲资源时，基本上都可以通过“队列”这种数据结构来实现请求排队。

队列最大的特点就是先进先出，主要的两个操作是入队和出队。跟栈一样，它既可以用数组来实现，也可以用链表来实现。用数组实现的叫顺序队列，用链表实现的叫链式队列。特别是长得像一个环的循环队列。在数组实现队列的时候，会有数据搬移操作，要想解决数据搬移的问题，我们就需要像环一样的循环队列。

## 10 | 递归：如何用三行代码找到“最终推荐人”？

递归需要满足的三个条件:
- 1. 一个问题的解可以分解为几个子问题的解
- 2. 这个问题与分解之后的子问题，除了数据规模不同，求解思路完全一样
- 3. 存在递归终止条件

写递归代码的关键就是找到如何将大问题分解为小问题的规律，并且基于此写出递推公式，然后再推敲终止条件，最后将递推公式和终止条件翻译成代码。

编写递归代码的关键是，只要遇到递归，我们就把它抽象成一个递推公式，不用想一层层的调用关系，不要试图用人脑去分解递归的每个步骤。

### 注意
- 递归代码要警惕堆栈溢出
- 递归代码要警惕重复计算

递归代码虽然简洁高效，但是，递归代码也有很多弊端。比如，堆栈溢出、重复计算、函数调用耗时多、空间复杂度高等，所以，在编写递归代码的时候，一定要控制好这些副作用。

# 11 | 排序（上）：为什么插入排序比冒泡排序更受欢迎？

## 排序算法的执行效率
最好、最坏、平时时间复杂度

## 排序算法的内存消耗
原地排序（Sorted in place）。原地排序算法，就是特指空间复杂度是 O(1) 的排序算法。


## 排序算法的稳定性
稳定性。这个概念是说，如果待排序的序列中存在值相等的元素，经过排序之后，相等元素之间原有的先后顺序不变。


插入排序和冒泡排序的时间复杂度相同，都是 O(n2)，在实际的软件开发里，为什么我们更倾向于使用插入排序算法而不是冒泡排序算法呢？

，冒泡排序不管怎么优化，元素交换的次数是一个固定值，是原始数据的逆序度。插入排序是同样的，不管怎么优化，元素移动的次数也等于原始数据的逆序度。但是，从代码实现上来看，冒泡排序的数据交换要比插入排序的数据移动要复杂，冒泡排序需要 3 个赋值操作，而插入排序只需要 1 个。

