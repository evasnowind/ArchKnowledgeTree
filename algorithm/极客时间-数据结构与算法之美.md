# 05 | 数组：为什么很多编程语言中数组都从0开始编号？

线性表：
- 数组
- 链表
- 队列
- 栈
- ……

非线性表：
- 二叉树
- 堆
- 图
- ……


数组支持随机访问，根据下标随机访问的时间复杂度为 O(1)。

如果使用 ArrayList，我们就完全不需要关心底层的扩容逻辑，ArrayList 已经帮我们实现好了。每次存储空间不够的时候，它都会将空间自动扩容为 1.5 倍大小。

因为扩容操作涉及内存申请和数据搬移，是比较耗时的。所以，**如果事先能确定需要存储的数据大小，最好在创建 ArrayList 的时候事先指定数据大小。**

# 06 | 链表（上）：如何实现LRU缓存淘汰算法?

## 链表类型
- 单链表
- 双向链表
- 循环链表

## 如何基于链表实现 LRU 缓存淘汰算法？
维护一个有序单链表，越靠近链表尾部的结点是越早之前访问的。当有一个新的数据被访问时，我们从链表头开始顺序遍历链表。
1. 如果此数据之前已经被缓存在链表中了，我们遍历得到这个数据对应的结点，并将其从原来的位置删除，然后再插入到链表的头部。
2. 如果此数据没有在缓存链表中，又可以分为两种情况：
   - 如果此时缓存未满，则将此结点直接插入到链表的头部；
   - 如果此时缓存已满，则链表尾结点删除，将新的数据结点插入链表的头部。

这是一道leetcode题目，这个思路是O(n)时间复杂度。

进一步优化：引入散列表（Hash table）来记录每个数据的位置，将缓存访问的时间复杂度降到 O(1)。

# 07 | 链表（下）：如何轻松写出正确的链表代码？

## 技巧一：理解指针或引用的含义
将某个变量赋值给指针，实际上就是将这个变量的地址赋值给指针，或者反过来说，指针中存储了这个变量的内存地址，指向了这个变量，通过指针就能找到这个变量。

## 技巧二：警惕指针丢失和内存泄漏

插入结点时，一定要注意操作的顺序
删除链表结点时，也一定要记得手动释放内存空间

## 技巧三：利用哨兵简化实现难度
针对链表的插入、删除操作，需要对插入第一个结点和删除最后一个结点的情况进行特殊处理。


## 技巧四：重点留意边界条件处理

## 技巧五：举例画图，辅助思考

## 技巧六：多写多练，没有捷径
5 个常见的链表操作:
- 单链表反转
- 链表中环的检测
- 两个有序的链表合并
- 删除链表倒数第 n 个结点
- 求链表的中间结点

练习题LeetCode对应编号：206，141，21，19，876