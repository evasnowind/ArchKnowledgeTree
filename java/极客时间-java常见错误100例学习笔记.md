[TOC]

# 01 | 使用了并发工具类库，线程安全就高枕无忧了吗？

## 1. 使用ThreadLocal后没有及时清空导致数据错乱

spring boot/spring mvc程序运行在 Tomcat 中，执行程序的线程是 Tomcat 的工作线程，而 Tomcat 的工作线程是基于线程池的。

**使用类似 ThreadLocal 工具来存放一些数据时，需要特别注意在代码运行完后，显式地去清空设置的数据。**

## 2. ConcurrentHashMap 只能保证提供的原子性读写操作是线程安全的
ConcurrentHashMap 对外提供的方法或能力的限制：
- 使用了 ConcurrentHashMap，不代表对它的多个操作之间的状态是一致的，是没有其他线程在操作它的，如果需要确保需要手动加锁。
- 诸如 size、isEmpty 和 containsValue 等聚合方法，在并发情况下可能会反映 ConcurrentHashMap 的中间状态。因此在并发情况下，这些方法的返回值只能用作参考，而不能用于流程控制
- 诸如 putAll 这样的聚合方法也不能确保原子性，在 putAll 的过程中去获取数据可能会获取到部分数据。

## 3. 没有充分了解并发工具的特性，从而无法发挥其威力
ConcurrentHashMap的computeIfAbsent方法：可以用于使用 Map 来统计 Key 出现次数的场景
LongAdder类的使用

## 4. 没有认清并发工具的使用场景，因而导致性能问题
CopyOnWriteArrayList适用于读多的情况，因为每次add都会重新建一个List，成本很高

# 02 | 代码加锁：不要让“锁”事成为烦心事

## 1. 加锁前要清楚锁和被保护的对象是不是一个层面的
静态字段属于类，类级别的锁才能保护；而非静态字段属于类实例，实例级别的锁就可以保护。

## 2. 加锁要考虑锁的粒度和场景问题
即使我们确实有一些共享资源需要保护，也要尽可能降低锁的粒度，仅对必要的代码块甚至是需要保护的资源本身加锁。
——不要在所有业务代码的方法上加synchronized关键字，要看需求，否则会损失性能

## 3. 如果精细化考虑了锁应用范围后，性能还无法满足需求的话，我们就要考虑另一个维度的粒度问题了，即：区分读写场景以及资源的访问冲突，考虑使用悲观方式的锁还是乐观方式的锁。
作者分享的观点：
- 对于读写比例差异明显的场景，考虑使用 ReentrantReadWriteLock 细化区分读写锁，来提高性能。
- 如果你的 JDK 版本高于 1.8、共享资源的冲突概率也没那么大的话，考虑使用 StampedLock 的乐观读的特性，进一步提高性能。
- JDK 里 ReentrantLock 和 ReentrantReadWriteLock 都提供了公平锁的版本，在没有明确需求的情况下不要轻易开启公平锁特性，在任务很轻的情况下开启公平锁可能会让性能下降上百倍。

## 4. 多把锁要小心死锁问题
业务逻辑中有多把锁时要考虑死锁问题，通常的规避方案是，避免无限等待和循环等待。
**如果业务逻辑中锁的实现比较复杂的话，要仔细看看加锁和释放是否配对，是否有遗漏释放或重复释放的可能性；并且对于分布式锁要考虑锁自动超时释放了，而业务逻辑却还在进行的情况下，如果别的线线程或进程拿到了相同的锁，可能会导致重复执行。**
**如果你的业务代码涉及复杂的锁操作，强烈建议 Mock 相关外部接口或数据库操作后对应用代码进行压测，通过压测排除锁误用带来的性能问题和死锁问题。**


# 03 | 线程池：业务代码最常用也最容易犯错的组件

## 1. 线程池的声明需要手动进行

**不建议使用 Executors 提供的两种快捷的线程池（newFixedThreadPool和newCachedThreadPool）**
FixedThreadPool会创建LinkedBlockingQueue对象，队列默认长度是Integer.MAX_VALUE，虽然线程数量固定，但任务较多且执行较慢的情况下，该队列可能会导致OOM。

阿里巴巴java开发规范原文：
```
线程池不允许使用Executors去创建，而是通过ThreadPoolExecutor的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险。
说明：Executors返回的线程池对象的弊端如下：
1） FixedThreadPool和SingleThreadPool： 允许的请求队列长度为Integer.MAX_VALUE，可能会堆积大量的请求，从而导致OOM。 
2） CachedThreadPool： 允许的创建线程数量为Integer.MAX_VALUE，可能会创建大量的线程，从而导致OOM。
```

- 需要根据自己的场景、并发情况来评估线程池的几个核心参数，包括核心线程数、最大线程数、线程回收策略、工作队列的类型，以及拒绝策略，确保线程池的工作行为符合需求，一般都需要设置有界的工作队列和可控的线程数。
- 任何时候，都应该为自定义线程池指定有意义的名称，以方便排查问题。
- 用一些监控手段来观察线程池的状态。

## 2. 线程池线程管理策略详解

注意一定要弄清楚线程池默认的行为模式：核心线程、最大线程、队列容量的含义
我们也可以通过一些手段来改变这些默认工作行为，比如：
- 声明线程池后立即调用 prestartAllCoreThreads 方法，来启动所有核心线程；
- 传入 true 给 allowCoreThreadTimeOut 方法，来让线程池在空闲的时候同样回收核心线程。

我们有没有办法让线程池更激进一点，优先开启更多的线程，而把队列当成一个后备方案呢？
**——可以自行实现试试。**

## 3. 务必确认清楚线程池本身是不是复用的

$\color{red}{注意使用工具库时，看看工具库的代码实现，是否真的如同我们所思考的那样。}$

## 4. 需要仔细斟酌线程池的混用策略
**要根据任务的“轻重缓急”来指定线程池的核心参数，包括线程数、回收策略和任务队列：**
- 对于执行比较慢、数量不大的 IO 任务，或许要考虑更多的线程数，而不需要太大的队列。
- 而对于吞吐量较大的计算型任务，线程数量不宜过多，可以是 CPU 核数或核数 *2

盲目复用线程池混用线程的问题在于，别人定义的线程池属性不一定适合你的任务，而且混用会相互干扰。

## 5. Java 8 的 parallel stream 功能，可以让我们很方便地并行处理集合中的元素，其背后是共享同一个 ForkJoinPool，默认并行度是 CPU 核数 -1。
$\color{red}{共享同一个 ForkJoinPool!!!}$
对于 CPU 绑定的任务来说，使用这样的配置比较合适，但如果集合操作涉及同步 IO 操作的话（比如数据库操作、外部服务调用等），建议自定义一个 ForkJoinPool（或普通线程池）。


# 04 | 连接池：别让连接池帮了倒忙
## 1. 注意鉴别客户端 SDK 是否基于连接池
**使用连接池务必确保复用**
因为 TCP 基于字节流，在多线程的情况下对同一连接进行复用，可能会产生线程安全问题。

### 使用JedisPool而不是Jedis，Jedis基于Connection，不是线程安全的


## 2. 使用连接池务必确保复用
池一定是用来复用的，否则其使用代价会比每次创建单一对象更大。对连接池来说更是如此
### apache HttpClient：CloseableHttpClient 是内部带有连接池的 API，其背后是连接池，最佳实践一定是复用。

## 3. 连接池的配置不是一成不变的
最大连接数不是设置得越大越好。
连接池最大连接数设置得太小，很可能会因为获取连接的等待时间太长，导致吞吐量低下，甚至超时无法获取连接。
对类似数据库连接池的重要资源进行持续检测，并设置一半的使用量作为报警阈值，出现预警后及时扩容。
**要强调的是，修改配置参数务必验证是否生效，并且在监控系统中确认参数是否生效、是否合理!!!**

